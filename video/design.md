# 视频服务

## server

- 视频上传
- 视频转码
- 视频存储 - 视频的元数据应该由browse管理

### 设计

- 需要消息队列 还有视频处理的工具
- 码率：原画、720p、360p

#### 工具

最终方案

使用javacv-platform

JavaCPP Presets For FFmpeg

- github https://github.com/bytedeco/javacpp-presets/tree/master/ffmpeg
- api 文档 http://bytedeco.org/javacpp-presets/ffmpeg/apidocs/

Apache Commons CLI + FFmpeg

- 博客
  - https://segmentfault.com/a/1190000044568143
  - https://www.zhihu.com/question/1918800274035806859

## client

## 表设计

> 暂不用

## 转码问题

两个冲突的点

1. **同机部署** → 资源竞争（上传和转码抢 CPU / 内存 / IO 带宽）。
2. **异机部署** → 存储要走网络，会多一次 I/O。

### **方案 1：同机部署 + 资源隔离（推荐）**

思路是：

* 服务逻辑上依然拆分成“上传服务”和“转码服务”，但部署在同一台机器。
* 通过 **Docker CPU/内存限额** 或 **cgroup** 限制转码服务的资源占用，让上传服务有稳定的资源，不会被卡死。
* 两个服务共享本地磁盘路径（零额外 I/O）。

优点：

* 没有额外的存储 I/O。
* 保留了逻辑解耦，后期迁移到多机非常方便。
* 限制转码服务的 CPU 线程数（比如 ffmpeg 加 `-threads N`），减少资源抢占。

缺点：

* 总算力固定，处理峰值速度受限于单机性能。

---

### **方案 2：异机部署 + 高速共享存储**

思路是：

* 上传服务在**本机磁盘**写文件，但这个磁盘是一个 **共享文件系统**（NFS、CephFS、GlusterFS 甚至 NAS）。
* 转码服务（异机）直接从共享文件系统读取，不需要额外复制。
* 存储到对象存储时，也可以直接由转码服务写入。

优点：

* 无需额外文件复制，跨机也可以零冗余。
* 可以横向扩展转码节点。

缺点：

* 部署成本高，需要有可靠的共享存储架构。
* 网络带宽和延迟会影响转码速度（尤其是大文件）。

---

### **方案 3：异机部署 + 临时对象存储（分块上传）**

思路是：

* 上传服务接收文件后，直接将分块并发写入对象存储（临时桶）。
* 转码服务（异机）直接从对象存储拉取进行转码。
* 转码完成后，存储到正式桶。

优点：

* 转码节点完全无状态，随时扩容缩容。
* 不依赖本地磁盘，云环境下更方便。

缺点：

* 上传到对象存储 → 再下载到转码节点 → 再上传结果，会有三次网络 I/O。
* 如果网络不是高速专线，这一步会很慢。

